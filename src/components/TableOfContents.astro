---
interface Props {
  headings: Array<{
    depth: number;
    slug: string;
    text: string;
  }>;
  minDepth?: number; // Minimum heading depth to include (default: 2)
  maxDepth?: number; // Maximum heading depth to include (default: 4)
}

const { headings, minDepth = 2, maxDepth = 4 } = Astro.props;

// Filter headings based on depth range
const tocHeadings = headings.filter(h => h.depth >= minDepth && h.depth <= maxDepth);
---

<nav class="table-of-contents" aria-label="Table of Contents">
  <details class="toc-container" open>
    <summary>
      <h2>On This Page</h2>
      <span class="toggle-icon" aria-hidden="true">â–¼</span>
    </summary>
    <ul class="toc-list">
      {tocHeadings.map((heading) => (
        <li class={`toc-item depth-${heading.depth}`}>
          <a href={`#${heading.slug}`} class="toc-link">
            {heading.text}
          </a>
        </li>
      ))}
    </ul>
  </details>
</nav>

<style>
  .table-of-contents {
    background: white;
    border: 1px solid var(--border, #e5e7eb);
    border-radius: 0.5rem;
    padding: 1.5rem;
  }

  .toc-container summary {
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    list-style: none;
    margin-bottom: 1rem;
  }

  .toc-container summary::-webkit-details-marker {
    display: none;
  }

  .toc-container summary h2 {
    margin: 0;
    font-size: 1.25rem;
    color: var(--text, #1f2937);
    font-weight: 600;
  }

  .toggle-icon {
    color: var(--gray, #6b7280);
    font-size: 0.875rem;
    transition: transform 0.2s ease;
  }

  .toc-container[open] .toggle-icon {
    transform: rotate(180deg);
  }

  .toc-list {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .toc-item {
    margin-bottom: 0.5rem;
  }

  /* Hierarchical indentation */
  .toc-item.depth-1 {
    padding-left: 0;
    font-weight: 600;
  }

  .toc-item.depth-2 {
    padding-left: 0;
  }

  .toc-item.depth-3 {
    padding-left: 1rem;
  }

  .toc-item.depth-4 {
    padding-left: 2rem;
  }

  .toc-link {
    display: block;
    color: var(--gray, #6b7280);
    text-decoration: none;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    transition: all 0.2s ease;
    font-size: 0.9375rem;
    line-height: 1.5;
  }

  .toc-link:hover {
    color: var(--accent, #2563eb);
    text-decoration: underline;
    background: var(--accent-light, #eff6ff);
  }

  .toc-link:focus {
    outline: 2px solid var(--accent, #2563eb);
    outline-offset: 2px;
  }

  .toc-link.active {
    color: var(--accent, #2563eb);
    font-weight: 600;
    border-left: 3px solid var(--accent, #2563eb);
    padding-left: calc(0.5rem - 3px);
    background: var(--accent-light, #eff6ff);
  }

  /* Mobile styles */
  @media (max-width: 768px) {
    .table-of-contents {
      margin-bottom: 2rem;
    }

    .toc-container summary {
      padding: 0.5rem 0;
    }

    .toc-container:not([open]) summary {
      margin-bottom: 0;
    }
  }

  /* Desktop styles - for when used in sidebar */
  @media (min-width: 769px) {
    .toc-container summary {
      pointer-events: none; /* Keep open on desktop */
    }

    .toggle-icon {
      display: none; /* Hide toggle icon on desktop */
    }
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const tocLinks = document.querySelectorAll('.toc-link');
    
    // Function to update active link based on hash
    function updateActiveLink(hash: string) {
      tocLinks.forEach(link => {
        link.classList.remove('active');
        const href = link.getAttribute('href');
        if (href === hash) {
          link.classList.add('active');
        }
      });
    }

    // Update on page load
    if (window.location.hash) {
      updateActiveLink(window.location.hash);
    }

    // Update when hash changes (clicking ToC links or browser back/forward)
    window.addEventListener('hashchange', () => {
      updateActiveLink(window.location.hash);
    });

    // Build a map of sections that actually exist in the DOM
    const sectionMap = new Map();
    tocLinks.forEach(link => {
      const href = link.getAttribute('href');
      if (href) {
        const section = document.querySelector(href);
        if (section) {
          sectionMap.set(href, { link, section });
        }
      }
    });

    if (sectionMap.size === 0) return;

    const observerOptions = {
      rootMargin: '-20% 0px -60% 0px',
      threshold: 0
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const id = entry.target.getAttribute('id');
          const targetHref = `#${id}`;
          
          // Only update if we're not navigating via hash (to avoid conflicts)
          if (!window.location.hash || window.location.hash === targetHref) {
            updateActiveLink(targetHref);
            
            // Update URL hash without scrolling
            if (history.replaceState) {
              history.replaceState(null, '', targetHref);
            }
          }
        }
      });
    }, observerOptions);

    // Observe all sections
    sectionMap.forEach(({ section }) => {
      observer.observe(section);
    });

    // Auto-collapse ToC on mobile after clicking a link
    const isMobile = () => window.innerWidth < 769;
    
    tocLinks.forEach(link => {
      link.addEventListener('click', () => {
        if (isMobile()) {
          const details = document.querySelector('.toc-container');
          if (details instanceof HTMLDetailsElement) {
            // Small delay to allow smooth scroll to start
            setTimeout(() => {
              details.open = false;
            }, 100);
          }
        }
      });
    });
  });
</script>
