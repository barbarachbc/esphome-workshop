<!-- Lightbox Modal -->
<div id="lightbox" class="lightbox-overlay" aria-hidden="true" role="dialog" aria-modal="true">
  <div class="lightbox-container">
    <!-- Close button -->
    <button class="lightbox-close" aria-label="Close lightbox">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <line x1="18" y1="6" x2="6" y2="18"></line>
        <line x1="6" y1="6" x2="18" y2="18"></line>
      </svg>
    </button>
    
    <!-- Navigation -->
    <button class="lightbox-prev" aria-label="Previous image">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="15 18 9 12 15 6"></polyline>
      </svg>
    </button>
    <button class="lightbox-next" aria-label="Next image">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="9 18 15 12 9 6"></polyline>
      </svg>
    </button>
    
    <!-- Image container -->
    <div class="lightbox-image-wrapper">
      <img id="lightbox-image" src="" alt="" />
    </div>
    
    <!-- Counter -->
    <div class="lightbox-counter">
      <span id="lightbox-current">1</span> / <span id="lightbox-total">1</span>
    </div>
  </div>
</div>

<script>
  class LightboxManager {
    private images: HTMLImageElement[] = [];
    private currentIndex: number = 0;
    private overlay: HTMLElement | null = null;
    private lightboxImg: HTMLImageElement | null = null;
    private previouslyFocusedElement: HTMLElement | null = null;
    
    constructor() {
      this.overlay = document.getElementById('lightbox');
      this.lightboxImg = document.getElementById('lightbox-image') as HTMLImageElement;
      this.init();
    }
    
    init() {
      // Find all Astro-optimized images in content areas
      const contentImages = document.querySelectorAll<HTMLImageElement>(
        'img[data-image-component="true"]'
      );
      
      this.images = Array.from(contentImages);
      
      // Add click handlers to make images clickable
      this.images.forEach((img, index) => {
        img.style.cursor = 'pointer';
        img.setAttribute('tabindex', '0');
        img.setAttribute('role', 'button');
        img.setAttribute('aria-label', `View ${img.alt || 'image'} in lightbox`);
        
        img.addEventListener('click', () => this.open(index));
        img.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            this.open(index);
          }
        });
      });
      
      // Setup event listeners
      this.setupEventListeners();
    }
    
    setupEventListeners() {
      // Close button
      document.querySelector('.lightbox-close')?.addEventListener('click', (e) => {
        e.stopPropagation();
        this.close();
      });
      
      // Navigation buttons
      document.querySelector('.lightbox-prev')?.addEventListener('click', (e) => {
        e.stopPropagation();
        this.prev();
      });
      
      document.querySelector('.lightbox-next')?.addEventListener('click', (e) => {
        e.stopPropagation();
        this.next();
      });
      
      // Click overlay background to close
      this.overlay?.addEventListener('click', (e) => {
        if (e.target === this.overlay) {
          this.close();
        }
      });
      
      // Keyboard navigation
      document.addEventListener('keydown', this.handleKeydown.bind(this));
    }
    
    open(index: number) {
      this.currentIndex = index;
      this.previouslyFocusedElement = document.activeElement as HTMLElement;
      this.render();
      
      this.overlay?.classList.add('active');
      this.overlay?.setAttribute('aria-hidden', 'false');
      
      // Prevent body scroll
      document.body.style.overflow = 'hidden';
      
      // Focus close button
      (document.querySelector('.lightbox-close') as HTMLElement)?.focus();
    }
    
    close() {
      this.overlay?.classList.remove('active');
      this.overlay?.setAttribute('aria-hidden', 'true');
      document.body.style.overflow = '';
      
      // Restore focus
      this.previouslyFocusedElement?.focus();
    }
    
    next() {
      this.currentIndex = (this.currentIndex + 1) % this.images.length;
      this.render();
    }
    
    prev() {
      this.currentIndex = (this.currentIndex - 1 + this.images.length) % this.images.length;
      this.render();
    }
    
    render() {
      if (!this.lightboxImg) return;
      
      const sourceImg = this.images[this.currentIndex];
      
      // Copy all image attributes to leverage browser's srcset selection
      this.lightboxImg.src = sourceImg.src;
      this.lightboxImg.alt = sourceImg.alt;
      
      // Copy srcset and sizes - browser will pick the best resolution
      if (sourceImg.hasAttribute('srcset')) {
        this.lightboxImg.setAttribute('srcset', sourceImg.getAttribute('srcset')!);
      } else {
        this.lightboxImg.removeAttribute('srcset');
      }
      
      if (sourceImg.hasAttribute('sizes')) {
        this.lightboxImg.setAttribute('sizes', sourceImg.getAttribute('sizes')!);
      } else {
        // Override sizes for lightbox container (90vw x 90vh)
        this.lightboxImg.setAttribute('sizes', '90vw');
      }
      
      // Update counter
      document.getElementById('lightbox-current')!.textContent = String(this.currentIndex + 1);
      document.getElementById('lightbox-total')!.textContent = String(this.images.length);
      
      // Hide/show navigation based on image count
      const prevBtn = document.querySelector('.lightbox-prev') as HTMLElement;
      const nextBtn = document.querySelector('.lightbox-next') as HTMLElement;
      const counter = document.querySelector('.lightbox-counter') as HTMLElement;
      
      if (this.images.length <= 1) {
        prevBtn.style.display = 'none';
        nextBtn.style.display = 'none';
        counter.style.display = 'none';
      } else {
        prevBtn.style.display = 'flex';
        nextBtn.style.display = 'flex';
        counter.style.display = 'block';
      }
    }
    
    handleKeydown(e: KeyboardEvent) {
      if (!this.overlay?.classList.contains('active')) return;
      
      switch(e.key) {
        case 'Escape':
          this.close();
          break;
        case 'ArrowLeft':
          e.preventDefault();
          this.prev();
          break;
        case 'ArrowRight':
          e.preventDefault();
          this.next();
          break;
      }
    }
  }
  
  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => new LightboxManager());
  } else {
    new LightboxManager();
  }
</script>
